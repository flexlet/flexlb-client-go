// Copyright (c) 2022 Yaohui Wang (yaohuiwang@outlook.com)
// FlexLB is licensed under Mulan PubL v2.
// You can use this software according to the terms and conditions of the Mulan PubL v2.
// You may obtain a copy of Mulan PubL v2 at:
//         http://license.coscl.org.cn/MulanPubL-2.0
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
// EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
// MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
// See the Mulan PubL v2 for more details.

// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BackendServer Backend server
//
// swagger:model BackendServer
type BackendServer struct {

	// check ssl options
	CheckSslOptions *BackendServerCheckSslOptions `json:"check_ssl_options,omitempty"`

	// Backend server IP address
	// Required: true
	// Pattern: ((^\s*((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))\s*$)|(^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$))
	Ipaddress string `json:"ipaddress"`

	// Backend server name
	// Required: true
	// Pattern: ^[A-Za-z0-9\-_.]{1,32}$
	Name string `json:"name"`

	// Backend server options
	Options *string `json:"options,omitempty"`

	// Backend server port
	// Required: true
	Port uint16 `json:"port"`
}

// Validate validates this backend server
func (m *BackendServer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCheckSslOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIpaddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePort(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BackendServer) validateCheckSslOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.CheckSslOptions) { // not required
		return nil
	}

	if m.CheckSslOptions != nil {
		if err := m.CheckSslOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("check_ssl_options")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("check_ssl_options")
			}
			return err
		}
	}

	return nil
}

func (m *BackendServer) validateIpaddress(formats strfmt.Registry) error {

	if err := validate.RequiredString("ipaddress", "body", m.Ipaddress); err != nil {
		return err
	}

	if err := validate.Pattern("ipaddress", "body", m.Ipaddress, `((^\s*((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))\s*$)|(^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$))`); err != nil {
		return err
	}

	return nil
}

func (m *BackendServer) validateName(formats strfmt.Registry) error {

	if err := validate.RequiredString("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.Pattern("name", "body", m.Name, `^[A-Za-z0-9\-_.]{1,32}$`); err != nil {
		return err
	}

	return nil
}

func (m *BackendServer) validatePort(formats strfmt.Registry) error {

	if err := validate.Required("port", "body", uint16(m.Port)); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this backend server based on the context it is used
func (m *BackendServer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCheckSslOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BackendServer) contextValidateCheckSslOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.CheckSslOptions != nil {
		if err := m.CheckSslOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("check_ssl_options")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("check_ssl_options")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BackendServer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BackendServer) UnmarshalBinary(b []byte) error {
	var res BackendServer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// BackendServerCheckSslOptions Backend check commands
//
// swagger:model BackendServerCheckSslOptions
type BackendServerCheckSslOptions struct {

	// ca cert
	CaCert *string `json:"ca_cert,omitempty"`

	// client cert
	ClientCert string `json:"client_cert,omitempty"`

	// client key
	ClientKey string `json:"client_key,omitempty"`

	// verify
	// Enum: [none]
	Verify *string `json:"verify,omitempty"`
}

// Validate validates this backend server check ssl options
func (m *BackendServerCheckSslOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateVerify(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var backendServerCheckSslOptionsTypeVerifyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		backendServerCheckSslOptionsTypeVerifyPropEnum = append(backendServerCheckSslOptionsTypeVerifyPropEnum, v)
	}
}

const (

	// BackendServerCheckSslOptionsVerifyNone captures enum value "none"
	BackendServerCheckSslOptionsVerifyNone string = "none"
)

// prop value enum
func (m *BackendServerCheckSslOptions) validateVerifyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, backendServerCheckSslOptionsTypeVerifyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *BackendServerCheckSslOptions) validateVerify(formats strfmt.Registry) error {
	if swag.IsZero(m.Verify) { // not required
		return nil
	}

	// value enum
	if err := m.validateVerifyEnum("check_ssl_options"+"."+"verify", "body", *m.Verify); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this backend server check ssl options based on context it is used
func (m *BackendServerCheckSslOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *BackendServerCheckSslOptions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BackendServerCheckSslOptions) UnmarshalBinary(b []byte) error {
	var res BackendServerCheckSslOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
